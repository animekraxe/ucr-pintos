			+--------------------+
			|        CS 153      |
			| PROJECT 1: THREADS |
			|   DESIGN DOCUMENT  |
			+--------------------+
				   
---- GROUP ----

>> Fill in the names and email addresses of your group members.

Brandon Huynh <bhuyn006@ucr.edu>

---- PRELIMINARIES ----

>> If you have any preliminary comments on your submission, notes for the
>> TAs, or extra credit, please give them here.

>> Please cite any offline or online sources you consulted while
>> preparing your submission, other than the Pintos documentation, course
>> text, lecture notes, and course staff.

			     ALARM CLOCK
			     ===========

---- DATA STRUCTURES ----

>> A1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

Added to struct thread:

unsigned sleepTicks;	
/* 
	sleepTicks is used for counting down how many ticks left the thread has to sleep.
	A thread is not asleep if sleepTicks is 0.
*/

struct list_elem sleepelem; /* List element for thread in the sleeping threads list */

Added new static variable:
static struct list wait_list; /* List of threads that are sleeping for timer */

---- ALGORITHMS ----

>> A2: Briefly describe what happens in a call to timer_sleep(),
>> including the effects of the timer interrupt handler.

Disable interrupts to safely block the current thread. Set the current
thread's sleepTick count to amount of ticks requested to sleep. Add
the thread to the sleeping list, then block the thread and reenable interrupts.

For the timer interrupt handler, we process the sleeping list. We go
through each thread in the list and decrement its sleepTick count if it's non-zero.
If it hit's zero, we remove it from the sleeping list and unblock it, which adds
it back to the ready list.

>> A3: What steps are taken to minimize the amount of time spent in
>> the timer interrupt handler?

We query the sleep list only, removing as we go along. We never have to
update sleepTicks if there is nothing in the sleep_list.

---- SYNCHRONIZATION ----

>> A4: How are race conditions avoided when multiple threads call
>> timer_sleep() simultaneously?

We disable interrupts before setting sleepTicks and adding to the sleeping list.
This way, we avoid accessing issues with the shared sleeping list.

>> A5: How are race conditions avoided when a timer interrupt occurs
>> during a call to timer_sleep()?

We disable interrupts each time we try to access and process the sleeping list.
This way, the sleeping_list cannot be corrupted mid-processing.

---- RATIONALE ----

>> A6: Why did you choose this design?  In what ways is it superior to
>> another design you considered?

I thought at first of keeping track of ticks in the list of all threads, but
figured it was less work to move threads over to a sleeping list and only process
those by countign down if they're asleep. I wanted to do an ordered list,
and insert by sleeping time, so I could only process the ones in the front when
necessary. I thought it would be too much work, because I had not yet realized
the list.c had functions to do all of this for you.

			 PRIORITY SCHEDULING
			 ===================

---- DATA STRUCTURES ----

>> B1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

Added to struct thread:
    int base_priority;                  /* Base Priority, non-donated */
    struct list waitlock_list;          /* List of threads waiting for a lock this thread holds */
    struct list_elem waitlockelem;      /* List element for lock wait list */
    struct lock* waitlock;              /* The lock this thread is waiting for */

>> B2: Explain the data structure used to track priority donation.
>> Use ASCII art to diagram a nested donation.  (Alternately, submit a
>> .png file.)

To keep track of priority donations, we use the waitlock_list added to 
struct thread (mentioned above). The waitlock_list is kept in sorted
order, from highest priority to least. We can check the front element of list
quickly to determine whether priority donation is required.

Priority donation is needed if the front element of waitlock_list is greater than
our current priority. Nested donations simply means that a thread has priority of
the front element in it's waitlock_list. That front_element has priority of the front_element in
it's own waitlock_list, and so on recursively.

Example:
H wants to acquire lock B, inserting itself in sorted order into M's waitlock_list.
H then "updates M's priority". This means it checks M's front list element and raises 
M's priority if needed. It recursively follows this process, by checking the holder of each lock
that a thread is waiting for (through the waitlock pointer in struct thread). It does this
until there are no more threads whose priority needs updating.

Ascii Example:
Given Threads H, M, L.
Given Locks A, B;

Syntax L(H):[H, M, L] means L has current priority (H) and has threads H, M, and L, in it's waitlock_list.

L acquires lock A:

L(L):[] 

M holds lock B.
M tries to acquire lock A:

M(M):[] --> L(M):[M];

H tries to acquire lock B:

H(H):[] --> M(H):[H] --> L(H):[M]

---- ALGORITHMS ----

>> B3: How do you ensure that the highest priority thread waiting for
>> a lock, semaphore, or condition variable wakes up first?

We keep their semaphore waiter lists in sorted ordered.
This means the highest_priority thread is always at the front. On sema_up,
we remove from waiters and unblock the front thread. Since priority donations
can cause the semaphore waiter list to become unsorted, we sort the list before
popping the front.

>> B4: Describe the sequence of events when a call to lock_acquire()
>> causes a priority donation.  How is nested donation handled?

When we call lock_acquire, and that lock is owned by another thread, we add
the current thread to the holder thread's waitlock_list. We then "update priority"
on the holder thread.

Updating priority causes the holder thread to reevaluate the state of it's 
waitlock_list. It linearly checks if ONE SINGLE thread is out of order and reinserts it. 
This saves us from having to resort the whole thread. It then determines if this new
change requires it to raise its own priority by checking the front of the list.

Nested donations are handled like so:
The update priority process happens recursively. After the lock holder thread
update's its priority, it will call the function on the holder of the lock it is
waiting on (if one exists), until there are no more nested threads.

>> B5: Describe the sequence of events when lock_release() is called
>> on a lock that a higher-priority thread is waiting for.

On lock release, the lock holder thread will remove all threads in
it's waitlock_list who were waiting for that lock. It reverts
back to it's base_priority. It then checks the front of the list
and adopts a new donated priority if that thread has a higher
priority than it's base priority. It then recursively updates
that priority in other threads through the update priority process
described in B4.

---- SYNCHRONIZATION ----

>> B6: Describe a potential race in thread_set_priority() and explain
>> how your implementation avoids it.  Can you use a lock to avoid
>> this race?

Race conditions could occur if a thread attempts to set it's own priority,
while another thread is updating that thread's priority due to
priority donation.

We avoid this by disabling interrupts. We cannot use locks because
the priority donation that causes this occurs during lock acquire and release.

---- RATIONALE ----

>> B7: Why did you choose this design?  In what ways is it superior to
>> another design you considered?

I chose this design because I considered it more effective than storing
a list of waiters in each lock, or having a global list of threads 
waiting for locks. It's good because the state of donations
is managed by the threads that are donating, instead of through
a shared resource that needs to be queried by multiple threads.

With this design, a thread informs the lock holder that updates need
to occur, rather than having the lock holder check on it's own. The
information needed to propogate updates through nested donations is
also stored right in the list of threads. So we can "give back" priority
donations simply be removing that information in the list.

			   SURVEY QUESTIONS
			   ================

Answering these questions is optional, but it will help us improve the
course in future quarters.  Feel free to tell us anything you
want--these questions are just to spur your thoughts.  You may also
choose to respond anonymously in the course evaluations at the end of
the quarter.

>> In your opinion, was this assignment, or any one of the problems
>> in it, too easy or too hard?  Did it take too long or too little time?

>> Did you find that working on a particular part of the assignment gave
>> you greater insight into some aspect of OS design?

>> Is there some particular fact or hint we should give students in
>> future quarters to help them solve the problems?  Conversely, did you
>> find any of our guidance to be misleading?

>> Do you have any suggestions for the TAs to more effectively assist
>> students, either for future quarters or the remaining projects?

>> Any other comments?
